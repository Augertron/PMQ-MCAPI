***TABLE OF CONTENTS***

    LICENSE
    PACKAGE CONTENTS
    LAUNCHING PROCESSES
    DEFINING ENDPOINTS
    CLEANER
    THE OTHER MAKEFILE
    THREAD SAFETY
    TEST ENVIRONMENT AND DEPENDENCIES
    IMPLEMENTATION SPECIFIC BEHAVIOR
    INTERNAL STRUCTURE OF IMPLEMENTATION
    IMPLEMENTATION SPECIFIC ERRORS

***LICENSE***

FOR THE LICENSE OF THIS SOFTWARE SEE LICENSE.txt

***PACKAGE CONTENTS***

Includes a POSIX message queue based MCAPI implementation, where each node is
supposed to be its own process. A "hello world" level example is provided as
well as unit tests and integration tests. Files and folders are explained in
more detail below:

FILES:

LICENSE.txt     | THE LICENSE OF THIS SOFTWARE
README.txt      | Instructions for building the provided "hello world" example
DETAILS.txt     | This document: Contains more detailed information about this
                  MCAPI implementation and provided files.
makefile        | Script to build and launch application processes.
                  More details in chapter LAUNCHING PROCESSES (below)
makefile.mcapi  | Script to build the implementation object files
                  More details in chapter THE OTHER MAKEFILE (below)

FOLDERS:

/example        | Contains the provided "hello world" example.
                  More details within README.TXT
/include        | Header files of both MCAPI specification and implementation
/src            | Source files of the MCAPI implementation
/obj            | Object files of MCAPI implementation.
                   ***WARNING*** provided makefiles may delete contents.
/utests         | Unit tests: Contains its own README with more details
/itests         | Integration tests: Contains its own README with more details

***LAUNCHING PROCESSES***

It is highly recommended to use the provided makefile or other script to
launch processes in correct order, with correct parameters and with correct
priority. Furthermore, the cleaner executable should be always ran before or
after application processes as it will unlink any residual message queues left
by previous runs of the application. If such residuals exist when application
is launched again, it will result undefined behavior. You may also want to make
sure that there are no multiple instances of same executable, but existing
makefile does not help with that.

Calling "make" with the provided makefile will first (re)build the cleaner,
build the object files of the MCAPI implementation and then build the
application executables while linking said objects files statically. After the
builds the cleaner is executed, processes are launched with "nice", which will
set their priorities for operating system scheduler. Processes are separated
with '&' so that they launch in parallel rather than in sequence. Makefile will
wait for the processes finish, before finally calling the cleaner again.

    example: make

Processes, their order, parameter etc are defined in makefile variable
"PROCESSES", while their respective build commands are defined in "PBUILD".

example:
    PROCESSES = nice -n 10 ./more_important & nice -n 11 ./less_important

example:
    PBUILD = make -f makefile.mcapi; gcc some_node.c obj/*.o -Iinclude -lrt

Object files in folder "obj" are supposed to be implementation object files,
which are statically linked to every application executable, while folder
"include" is needed to include their header files, so that the application may
access the functionality. Flag -lrt must be provided to compiler so that it
will be able to access the POSIX message queues.

Calling "clean" will rerun and rebuild the cleaner and also remove the
implementation object files.

    example: make clean

***DEFINING ENDPOINTS***

Each endpoint must be defined in file "includes/endpointlist.h" which is
statically linked with the implementation, the cleaner executable and
application executable. Each of them needs to refer to the content to access
endpoints. Every time this file is changed, implementation object files and
every executable must be rebuilt. In addition to defining the endpoints, the
definitions must be added to the list in the define file. PLEASE NOTICE THAT
THE FORMAT OF THE FILE IS NOT DESIGNED TO BE USER FRIENDLY, BUT INSTEAD SHOULD
BE GENERATED BY A THIRD PARTY TOOL.

example of definition usage in application:
    
    point = mcapi_endpoint_get( DEFINED_DOMAIN_ID, DEFINED_NODE_ID,
    DEFINED_PORT_ID, TIMEOUT, &status );

For defining endpoint identifier use following format:

    #define DEFINED_DOMAIN_ID FOO
    #define DEFINED_NODE_ID BAR
    #define DEFINED_PORT_ID BAZ

For each endpoint receiving or sending messages use following format:

    #define ENDPOINT_NAME_DEF { { DEFINED_DOMAIN_ID, DEFINED_NODE_ID, \
    DEFINED_PORT_ID }, MCAPI_NO_CHAN, CHAN_NO_DIR }

For scalar channels use format below. Replace SCALAR_SIZE_IN_BYTES with
1, 2, 4 or 8. Both endpoints of the channel must have the same scalar size.

    #define RECEIVING_NAME_DEF { { RECEIVING_DOMAIN_ID, RECEIVING_NODE_ID, \ 
    RECEIVING_PORT_ID }, MCAPI_SCL_CHAN, CHAN_DIR_RECV, { SENDING_DOMAIN_ID, \
    SENDING_NODE_ID, SENDING_PORT_ID }, SCALAR_SIZE_IN_BYTES }

    #define SENDING_NAME_DEF { { SENDING_DOMAIN_ID, SENDING_NODE_ID, \
    SENDING_PORT_ID }, MCAPI_SCL_CHAN, CHAN_DIR_SEND, { RECEIVING_DOMAIN_ID, 
    RECEIVING_NODE_ID, RECEIVING_PORT_ID }, SCALAR_SIZE_IN_BYTES }

In case of packet channels, replace "MCAPI_SCL_CHAN" with "MCAPI_PKT_CHAN".
Also, packet channels do not need definition of the scalar size.

To form the mandatory list of endpoints, use following format:

    #define DEF_LIST { ENDPOINT_NAME_DEF, RECEIVING_NAME_DEF, \
    SENDING_NAME_DEF, A_DEF_IN_SECOND_ROW }

example of endpoint identifier definition:

    #define THE_DOMAIN 1
    #define YELLOW_NODE 13
    #define YELLOW_MSG_IN 0

example of message endpoint definition:

    #define YELLOW_MSG { THE_DOMAIN, YELLOW_NODE, YELLOW_MSG_IN }
    #define YELLOW_MSG_DEF { YELLOW_MSG, MCAPI_NO_CHAN, CHAN_NO_DIR }

example of scalar channel definition:

    #define YELLOW_SIN {1, 13, 1}
    #define RED_SIN {1, 14, 1}
    #define YELLOW_SIN_DEF { YELLOW_SIN, MCAPI_SCL_CHAN, CHAN_DIR_RECV, RED_SIN, 2 }
    #define RED_SIN_DEF { RED_SIN, MCAPI_SCL_CHAN, CHAN_DIR_SEND, YELLOW_SIN, 2 }

example of packet channel definition:

    #define MAG_CYAN_SEND {1, 10, 0}
    #define MAG_CYAN_RECV {1, 11, 0}
    #define MAG_CYAN_SEND_DEF { MAG_CYAN_SEND, MCAPI_PKT_CHAN, CHAN_DIR_SEND, \
    MAG_CYAN_RECV, 0 }
    #define MAG_CYAN_RECV_DEF { MAG_CYAN_RECV, MCAPI_PKT_CHAN, CHAN_DIR_RECV, \ 
    MAG_CYAN_SEND, 0 }

example of list definition:

    #define DEF_LIST { YELLOW_MSG_DEF, YELLOW_SIN_DEF, RED_SIN_DEF, \
    MAG_CYAN_SEND_DEF, MAG_CYAN_RECV_DEF }

***CLEANER***

Cleaner is a simple executable, which will reconstruct names of all POSIX
message queues used by defined endpoints and call "mq_unlink" with said
name as a parameter. This will remove the name, but the message queue proper
will still exist if any process uses it. Thus, executing the cleaner while
application processes are running will result in undefined behavior.

Since the cleaner needs access to said defined endpoints, it needs to be
recompiled every time they are changed.

    example: ./clean

***THE OTHER MAKEFILE***

The other makefile, "makefile.mcapi", contains the build instruction for the
implementation object files. It is not intended to produce any kind of
standalone executable, but instead produce the object files to be statically
linked with the applications. The file has also a clean command, which
will remove the implementation object files from directory "obj".

    example: make -f makefile.mcapi
    example: make -f makefile.mcapi clean

***THREAD SAFETY***

This implementation IS NOT THREAD SAFE. However, if endpoints, channels,
buffers and other resources are not accessed by multiple threads of same
process at the same time, it should work. This was tested as a part of
integration tests.

***TEST ENVIRONMENT AND DEPENDENCIES***

THIS IMPLEMENTATION SHOULD RUN ON ANY LINUX FEATURING POSIX MESSAGE QUEUE,
C-COMPILER AND MAKE. However, tests were executed successfully in system
described below. Flag -lrt must be provided to compiler so that it will
be able to access the POSIX message queues. The implementation expects that
the comment notation "//" is supported by the compiler.

    Operating system: CentOS Release 6.5 (Final)
    Kernel Linux 2.6.32-431.3.1.el6.x86_64

    Processor: Intel(R) Core(TM)2 Quad CPU Q9650 @ 3.00GHZ

    Compiler: gcc (GCC) 4.8.1

    Make: GNU Make 3.81

***IMPLEMENTATION SPECIFIC BEHAVIOR***

Most of of the non-blocking functions are not implemented. Notable exceptions
are calls oriented with connecting, opening and closing channels. However,
said functions will not complete, unless mcapi_wait is called with request
handle provided from those functions and said call returns with MCAPI_SUCCESS.

Trying to send a message to an endpoint defined as a channel endpoint shall
result an error, even if it is not connected yet. Furthermore, also trying to
receive a message to such endpoint will result an error.

The only supported endpoint attribute is MCAPI_ENDP_ATTR_TIMEOUT, which will
set the timeout for the blocking send and receive calls. As such, the only
implemented attribute function is mcapi_endpoint_set_attribute. Node attributes
are not implemented either.

Other non-implemented functions include mcapi_pktchan_release_test,
mcapi_wait_any and mcapi_cancel.

***INTERNAL STRUCTURE OF IMPLEMENTATION***

Below tree illustrates dependencies between modules. Modules below are
dependent on those modules above which they are connected to with a line.
Indirect dependencies are culled out for simplicity. Names with extension ".h"
are merely headers, while extension-less names are modules with their own
implemented functions.

                   mca.h
                    |
                    ---------------------------\   endpointlist.h
                    |                           |   /
                    |                     endpointdef   mca_config.h
                    |                           |        /
                    |   ------------------mcapi_impl_spec.h
                    |  /                      
                mcapi.h
                    |
      --------------|------------
     /              |            \
    msg          channel        node
                    |             |
                 ---------     endpoint
                /         \
            scalar      packet

***IMPLEMENTATION SPECIFIC ERRORS***

All error codes used may be found in MCAPI specification. However, some errors
may occur on implementation specific situations. As a general rule, code
MCAPI_ERR_GENERAL is produced, if there was some bug in implementation or
an unexpected external disturbance. MCAPI_ERR_TRANSMISSION is produced usually
for same reasons. Usually MCAPI_ERR_GENERAL is accompanied by a print to the
standard error stream.

Calling mcapi_wait may also cause error prints, but in those cases it will
return MCAPI_TIMEOUT instead of any error code.

More specifics listed below:

mcapi_endpoint_get:
    MCAPI_ERR_GENERAL, if failed for other POSIX-call related reason than
    non-existing POSIX message queue.

mcapi_endpoint_create:
    MCAPI_ERR_GENERAL, when failed to open the POSIX message queue, obtain its
    attributes or obtained attributes did not match specified attributes.

mcapi_msg_send:
    MCAPI_ERR_GENERAL, when trying to send endpoint defined as channel.
    Does not produce an error print, however.
    MCAPI_ERR_TRANSMISSION, when POSIX call failed for other reason than 
    timeout. An error print will accompany this status code.

mcapi_msg_recv:
    MCAPI_ERR_GENERAL, when trying to receive at endpoint defined as channel
    or received message had priority outside configured limits.
    Produces an error print only in latter case.
    MCAPI_ERR_TRANSMISSION, when POSIX call failed for other reason than 
    timeout. An error print will accompany this status code.

mcapi_pktchan_connect_i:
    MCAPI_ERR_ENDP_INVALID includes case where trying to connect endpoints
    which are not defined to same channel.

mcapi_sclchan_connect_i:
    MCAPI_ERR_ENDP_INVALID includes case where trying to connect endpoints
    which are not defined to same channel.
    MCAPI_ERR_ATTR_INCOMPATIBLE, when the endpoints of the channel are defined
    for different scalar size.

mcapi_pktchan_send:
    MCAPI_ERR_TRANSMISSION, when POSIX call failed for other reason than 
    timeout. An error print will accompany this status code.

mcapi_pktchan_recv:
    MCAPI_ERR_TRANSMISSION, when failed for other reason than timeout.
    An error print will accompany this status code.
    MCAPI_ERR_GENERAL, if received POSIX message has unexpected priority.

mcapi_sclchan_send_uint64:
mcapi_sclchan_send_uint32:
mcapi_sclchan_send_uint16:
mcapi_sclchan_send_uint8:
    MCAPI_ERR_GENERAL, if the channel is not open, is used for operation of
    wrong scalar size or the POSIX call fails. Accompanies an error print
    only if the latter case is not because of timeout.

mcapi_sclchan_recv_uint64:
mcapi_sclchan_recv_uint32:
mcapi_sclchan_recv_uint16:
mcapi_sclchan_recv_uint8:
    MCAPI_ERR_GENERAL, if the channel is not open, is used for operation of
    wrong scalar size or the POSIX call fails. Accompanies an error print
    only if the latter case is not timeout or it is deemed failure because of 
    unexpected POSIX message priority.

mcapi_msg_available:
mcapi_pktchan_available:
mcapi_sclchan_available:
    MCAPI_ERR_GENERAL, when could not obtain the POSIX message queue
    attributes to check the count of received items.
